# strings (cadenas)

Operaciones sobre fragmentos de texto (conocidas como "cadenas" (`string`) en programación).

LAs cadenas so útiles para almacenar datos que se pueden representar en forma de texto. Algunas de las operaciones más utilizadas en cadenas son verificar su `length`, para construirlas y concatenarlas usando operadores de cadena `+ +=`, verificando la existencia o ubicación de sub cadenas con `indexOf()` o extraer sub cadenas con el método `substring()`.

Las cadenas (**strings**) son caracteres que pueden ser una frase o palabra y estas pueden darse con comillas dobles "", simples '' o invertidas `` que son acentos invertidos,
la diferencia es que con las invertidas podemos agregar variables dentro de la cadena con la sintaxis ${...}

Podemos ver que los manejamos como las variables, en este caso tenemos dos **var** y un **let** podemos ver abajo que las estamos declarando y lo que se llega a imprimir son los que están con la palabra reservada `console.log()`.

Veamos la diferencia entre ellas:

* La primera es una frase entre comillas dobles que sería un string común.

* La segunda está encerrada entre comillas simples que son prácticamente iguales que las de comillas dobles.

* La tercera tiene acentos invertidos, con los cuales nos dán la posibilidad de poder meter otras variables dentro, aquí se metio `frase1` para no combinar tipos, pero sin problemas se pueden utilizar otras variables como `${numero1}` esta es la mejor manera de insertar variables.

Los **backticks** son comillas de "funcionalidad extendida". Nos permiten incrustar variables y expresiones en una cadena de caracteres encerrándolas en `${...}`

~~~js
console.log("\n************* Cadenas **************\n");
var frase1 = "Ejemplo comillas dobles";

let frase2 = 'Ejemplo comillas simples';

var frase3 = `Ejemplo comillas ${frase1} invertidas`;

console.log(frase1 + "\n" + frase2 + "\n" + frase3);
~~~

Si estamos más atentos observamos que el primer `console.log` tiene los caracteres de "\n \n" nos deja un espacio de un enter en la consola.

en la ultima parte de `console.log()` que sería la operación sobre fragmentos de texto que queremos ver, entonces veríamos el resultado de:

~~~~cmd
Ejemplo comillas dobles
Ejemplo comillas simples
Ejemplo comillas Ejemplo comillas dobles invertidas
~~~~
Otro ejemplo:

```js
let nombre = "John";

// incrustar una variable
alert( `Hola, ${nombre}!` ); // Hola, John!

// incrustar una expresión
alert( `el resultado es ${1 + 2}` ); // el resultado es 3
```

La expresión dentro de `${...}` se evalúa y el resultado pasa a formar parte de la cadena. Podemos poner cualquier cosa ahí dentro: una variable como `name`, una expresión aritmética como `1 + 2`, o algo más complejo.

Otra ventaja de usar **backticks** es que nos permiten extender en múltiples líneas el `string`:

```js
let guestList = `Invitados:
* juan
* Pedro
* María
`;

alert(guestList); // una lista de invitados en múltiples líneas

Invitados:
juan
Pedro
María
```
---

## Comparar cadenas

Se usan los operadores menor que y mayor que.

```js
let a = "a"
let b = "b"

if (a < b) {  // true
  console.log(a + "es menor que" + b)
  }
  else if (a > b){
    console.log(a + "es mayor que" + b)
  }
    else {
    console.log(a + "y" +b+ "son iguales.")
  }


> aes menor queb
```
Se puede lograr un resultado similar usando el método `localCompare()` heredado por las instancias de `String`.

`a == b` compara las cadenas en `a` y `b` por ser igual en la forma habitual que distingue entre mayúsculas y minúsculas. Pero si se desea comparar sin importar mayúsculas y minúsculas:

```js
function esIgual(str1, str2){
  return str1.toUpperCase() === str2.toUpperCase()

} // esIgual
```

En esta función se utilizan mayúsculas en lugar de minúsculas, debido a problemas con ciertas conversiones de caracteres UTF-8.

---

## Caracteres especiales

Es posible crear strings de múltiples líneas usando comillas simples, usando un llamado “carácter de nueva línea”, escrito como ``\n``, lo que denota un salto de línea:

```js
let guestList = 'Invitados:\n * Juan\n * Pedro\n * Maria';

alert(guestList); // lista de invitados en múltiples líneas, igual a la de más arriba
```

Existen otros caracteres especiales.
|Caracter||Descripción|
|---:|---|---|
|``\n``||Nueva línea.|
|``\r``||En Windows, los archivos de texto usan combinación de dos caracteres `\r\n` para representar un corte de línea.|
|``\', \`, \" ``||Comillas.|
|``\\``||Barra invertida.|
|``\t``||Tabulación.|
|``\b, \f, \v``||Retroceso, avance de formulario, tabulación vertical - Se mencionan para ser exhaustivos. Actualmente en desuso.|

---

## Largo del `string`

La propiedad `length` contiene el largo del `string`:

```js
alert(`mi\n`.length); // 3
```
``\n`` es solo un caracter, por eso `3`.

### **NOTA**
`str.length` es una propiedad numérica, no una función. No hay que agregar paréntesis después de ella. No es `length()`, sino `.length`.

---

## Accediendo a caracteres

Para acceder a un caracter en la posición `pos`,  se debe usar corchetes, `[pos]`, o llamar al método `str.at(pos)`. El primer caracter comienza desde la posición cero ``[0]``:

```js
let str = `Hola`;

// el primer carácter
alert( str[0] ); // H
alert( str.at(0) ); // H

// el último carácter
alert( str[str.length - 1] ); // a
alert( str.at(-1) );
```
`at(pos)` tiene el beneficio de permitir una posición negativa. Si `pos` es negativa, se cuenta desde el final del string.

Así, `.at(-1)` significa el último caracter, y `.at(-2)` el el anterior a él, etc.

Los corchetes siempre devuelven `undefined` para negativos.

```js
let str = `Hola`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
```
Podemos además iterar sobre los caracteres usando `for..of`:

```js
for (let char of 'Hola') {
  alert(char); 
}
/*H
  o
  l
  a
  (char se convierte en "H", luego "o", luego "l", etc.)*/
```
## Los strings son inmutables

Los ``strings`` no pueden ser modificados en JvaScript.

Lo usual es crear un nuevo `string` y asignarlos a `str` reemplazando el `string` completo.

```js
let str = 'Hola';

str = 'h' + str[1] + str[2] + str[3]; // reemplaza el string

alert( str ); // hola

>hola
```
## Cambiando minúsculas y mayúsculas

`toLowerCase()` y `toUpperCase()` cambian los caracteres a minúscula y mayúscula respectivamente: 

```js
alert("Interfaz".toUpperCase());
alert("Interfaz".toLowerCase());

>INTERFAZ
>interfaz
```
Si queremos un solo caracter:

```js
console.log("Interfaz"[0].toLowerCase());

>i
```

```js
console.log("interfaz"[0].toUpperCase());

>I
```
## Buscando una sub cadena de caracteres

### **``str.indexOf``**

Este busca un `substr` en `str`, comenzando desde la posición entregada `pos`, y retorna la posición donde es encontrada la coincidencia o `-1` en caso de no encontrar nada.

```js
let str = "Widget con id";

console.log(str.indexOf("Widget")); // 0 "Widget es encontrado al comienzo"
console.log(str.indexOf("widget")); // -1 no se encontró, es key Sensitive

console.log(str.indexOf("id")); // 1 "id" es encontrado en la posición 1 (..idget con id)

>0
>-1
>1
```
Un segundo parámetro es opcional, nos permite buscar desde la posición entregada.

`id` en la posición `1` entonces comenzamos a buscar desde la posición `2`:

```js
let str = "Widget con id";

alert(str.indexOf("id", 2));

> 11
```

Ahora bien si queremos todas las concurrencias corramos `indexOf` en un bucle. Cada nuevo llamado es realizado utilizando la posición posterior a la encontrada anteriormente:

```js
const str = "Tres tristes tigres trigan trigo en un trigal, con tres tristes trigos trigrando por tres tigres";

let objetivo = "tres"; // La palabra que buscamos.

let pos = 0; // inicia desde la posición 0.

// para revisar las variables en la consola
console.log(str);
console.log(objetivo);
console.log(pos);

while (true){
  let encontrarPos = str.indexOf(objetivo, pos); 
  if(encontrarPos == -1) break; // en caso de haber coincidencias repetirá el proceso
  
  alert(`Encontrado en ${encontrarPos}`); // Muestra el resultado
  pos = encontrarPos + 1; // Continuar la búsqueda desde la siguiente posición al agregar +1
  
  console.log(pos); // muestra el resultado después de agregar +1 a la posición lo que nos muestra el resultado sumando ese +1
  
}
```
Algoritmo más corto:

```js
const str = "Tres tristes tigres trigan trigo en un trigal, con tres tristes trigos trigrando por tres tigres";

let objetivo = "tres"; // La palabra que buscamos.

let pos = -1;

while ((pos = str.indexOf(objetivo, pos +1))!= -1){
  alert(pos)
};
```
### `str.lastIndexOf(substr, position)`


```
```
```
```
```


---

[**&#11176;** *Anterior* &#11007;](/JavaScript/TeoriaJS/002_variables.md "Variables") 
[Siguiente **&#129042;**](/JavaScript/TeoriaJS/004_booleanosYOperadores.md "Valores booleanos y operadores")

[*Volver* **&ldca;**](/JavaScript/TeoriaJS/README.md "Regresar a página Principal") 
[*Subir* **&#11165;**](# "Ir al título")
